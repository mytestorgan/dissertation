\chapter{Синтез алгоритма буфера компенсации джиттера прибытия пакетов на основе робастного фильтра Калмана} \label{chapt3}

\section{Синтез математической модели процесса задержки} \label{sect3_1}
Перед синтезом алгоритма буфера компенсации джиттера необходимо определится с моделью задержки, которая представляет собой случайный гауссовский процесс. Достаточно конструктивной моделью случайного динамического процесса, является формирующий фильтр, описываемый уравнением состояния:

\begin{equation}\label{eq3:modelStatDif}
dx(t)/dt=\Phi(t)x(t)+G(t)\xi(t).
\end{equation}

Учитывая то, что мы рассматриваем информационный обмен в цифровой форме в виде пакетов, уравнение состояния, описывающее случайные изменения задержки на каждом из $k$ шагов дискретизации, представляется в виде:

\begin{equation}\label{eq3:modelStat}
x(k+1)=\Phi(k+1,k)x(k)+G(k)\xi(k),
\end{equation}

\noindent где $\Phi(k+1,k)$ - матрица перехода; $G(k)$ - порождающий коэффициент; $\xi(k)$ - порождающая последовательность выборки из гауссовского белого шума (ГБШ), со спектральной плотностью мощности $N_\xi$.

Процесс измерения задержки будем считать линейным. Уравнение наблюдения в линейном приближении представляется в виде:
\begin{equation}\label{eq3:Estim}
y(k)=Hx(k)+\nu(k),
\end{equation}

\noindent где $\nu(k)$ - фазовый шум ошибки измерения, являющийся порождающей последовательностью выборки из гауссовского белого шума со спектральной плотностью мощности $N_\nu$, некоррелированный с процессом $\xi(k)$. 
Модель описанная, уравнением (\ref{eq3:modelStat}), является стационарной, в реальных же ситуациях процесс задержки претерпевает различные случайные скачки и выбросы, обусловленные наличием инерционных элементов, таких как буферы, маршрутизаторы и др. Таким образом, могут быть выделены участки квазистационарности и определенные временные промежутки, где процесс $x(t)$ нестационарен.

Как мы видим из раздела \ref{chapt2}, процесс задержки имеет различные возмущения, вызванные различными причинами и, следовательно, математическая модель задержки должна учитывать все эти возмущения.
Очевидно, указанные выбросы и скачки задержки можно учитывать, как в уравнении состояния (\ref{eq3:modelStat}) так и в уравнении наблюдения (\ref{eq3:Estim}). Но смотря на то, что выбросы существенно ухудшают качество оценок, получаемых с помощью алгоритмов, оптимальных для гауссовского распределения. Разрабатываемый алгоритм компенсации джиттера должен будет игнорировать единичные выбросы. Тогда логичнее ввести выбросы задержки в уравнение наблюдения для того чтобы принимать выброс как ошибку наблюдения. И наоборот, при скачке задержки алгоритм компенсации джиттера должен, как можно раньше, увеличить размер буфера до необходимого значения, чтобы снизить пакетные потери. Тогда логичнее ввести скачки задержки в уравнение состояния.

Для описания помех $\xi(k)$, содержащие выбросы, могут быть использованы различные модели. Алгоритмы фильтрации, представленные в \cite{masreliez_ieee, masreliez_martin, ershov_lipcer, ershov}, основаны на описании помех в виде:


\begin{equation}\label{eq3:v}
\xi(k)=(1-r_v(k))\xi(k)+r_v(k)\xi_v(k),
\end{equation}

\begin{equation}\label{eq3:vp}
P[\xi(k)]=(1-\varepsilon)N[0,R_1(k)]+\varepsilon N[0,R_2(k)],
\end{equation}

\noindent где $\xi_v(k)$ - случайный процесс выброса, $P$ - плотность распределения вероятностей, $r_v(k)$ - случайная величина, принимающая значения 0 и 1 с вероятностями:

\begin{equation}\label{eq3:vpp}
P[r_v(k)=1]=\varepsilon, P[r_v(k)=0]=1-\varepsilon, ||R_2||>>||R_1||,
\end{equation}


Для описания случайного процесса, содержащего скачки, воспользуемся следующей моделью:

\begin{equation}\label{eq3:s}
x(k)=(1-r_s(k))x(k)+r_s(k)x_s(k),
\end{equation}

\begin{equation}\label{eq3:sp}
P[x(k)]=(1-\varepsilon)N[0,R_1(k)]+\varepsilon N[0,R_2(k)],
\end{equation}

\noindent где $x_s(k)$ - случайный процесс скачка, $r_s(k)$ - случайная величина, принимающая значения 0 и 1 с вероятностями:

\begin{equation}\label{eq3:spp}
P[r_s(k)=1]=\varepsilon, P[r_s(k)=0]=1-\varepsilon, ||R_2||>>||R_1||,
\end{equation}

\noindent где $x_s(k)$ представляет собой уравнение состояния случайного процесса скачка, а $r_s(k)$ представляет собой последовательностью случайных величин с двумя значениями на каждом шаге: «нуль» или «единица». Вероятности появления этих значений определяют долю засоренности скачками уравнения состояния. 
Учитывая то, что в рассматриваемой модели имеет место два типа уравнения состояния: для выброса и для скачка, необходимо дополнительное устройство, предназначенное для идентификации типа изменений, которое будет рассмотрено дальше.
С помощью предложенной модели случайного процесса сгенерируем ряд задержек с выбросами на рис. \ref{img3:modelJitter} a) и ряд задержек со скачками задержки на рис. \ref{img3:modelJitter} б).

\begin{figure} [h]
\begin{minipage}[h]{0.47\linewidth}
\center
\includegraphics[width=1\linewidth , height=4.5cm]{3chapter/3_1_a.eps} а) \\
\end{minipage}
\hfill
\begin{minipage}[h]{0.47\linewidth}
\center
\includegraphics[width=1\linewidth, height=4.5cm]{3chapter/3_1_b.eps} б) \\
\end{minipage}
\caption{Моделирование ряда задержек a) с выбросами, б) со скачками}
\label{img3:modelJitter}
\end{figure}

В результате была получена математическая модель изменения задержки, которая будет использоваться в дальнейшем для моделирования буфера компенсации джиттера.

\section{Анализ работы буфера компенсации джиттера и рабочих характеристик применительно к передаче потокового трафика через IP сети} \label{sect3_2}

Буфер воспроизведения в приемнике удерживает каждый принятый пакет на величину времени буфера, в котором компенсируется джиттер без чрезмерной задержки воспроизведения. Если межпакетная задержка будет превышать буферное время, буфер будет истощаться, и декодеру не будет хватать пакетов, чтобы воспроизводить речь. Это приводит к неравномерности воспроизведения речи. 
Согласно рекомендации ITU G.1020 \cite{G1020} пакеты, прибывающие к получателю, обрабатываются согласно процессу, изображенному на рис. \ref{img3:algh_pack}.

\begin{figure} [h]
  \center
\includegraphics[width=0.95\textwidth]{3chapter/3.eps}
  \caption{Алгоритм обработки сетевых пакетов}
  \label{img3:algh_pack}
\end{figure}

Прибывающие пакеты обрабатываются по мере их продвижения по стеку протокола. Показано, что некоторые виды ухудшений, такие как ошибки и джиттер преобразуются в другие ухудшения, такие как общие потери и общие ошибки.
На рис. 3.7 показан компромисс между задержкой и потерями, представленные в виде порога в диапазоне изменения задержки, основанном на размере буфера для сглаживания джиттера. Пакеты с задержкой находящейся в белой зоне будут приняты, тогда как пакеты с задержкой находящейся в черной зоне будут отброшены. Ясно, что чем больше задержка, тем больше пакетов прибудет до их времени воспроизведения и тем лучше будет компенсация джиттера. В тоже время, длительные задержки нежелательны, так как они ухудшают интерактивность человеческого общения. Отметим, что человеческое ухо терпимо относится к максимальным задержкам от 150 до 400 миллисекунд \cite{Moon}. Различные схемы кодирования также могут иметь различные допуски к потерям. Как следствие, хороший алгоритм компенсации джиттера основан на компромиссе между задержкой воспроизведения и потерями пакетов.
Рассмотрим изменение процесса потерь во время взаимодействие пакетов с буфером компенсации джиттера. В зависимости от критерия, определяющего решение принимать или отбрасывать каждый конкретный пакет из потока, в результате может полностью измениться распределение общих потерь и общей задержки. Например, если случайные битовые ошибки вызывают ошибки в контрольной сумме UDP, то потери пакетов будут иметь случайное распределение, по мере того как они поступают на прикладной уровень. Но, если несколько последовательных пакетов испытывают чрезмерные задержки, то дополнительные отбрасывания, вызванные ограничениями буфера компенсации джиттера, сделают общее распределение потерь еще и прерывистым.
Существуют обстоятельства, при которых порядок следования пакетов может изменяться во время их прохождения через сеть. При определенных условиях некоторые буферы компенсации джиттера неспособны восстановить порядок следования переупорядоченных пакетов и, в этом случае, они обозначаются как отброшенные пакеты.
Также рассмотрим влияние буфера компенсации джиттера на процесс задержки. На рис. \ref{img3:delNode} показаны основные элементы тракта передачи речи, которые вносят вклад в речевую задержку. Задержка сети переменна и для компенсации джиттера и восстановления допустимого интервала между пакетами используют буфер компенсации джиттера. Заметим, что пакеты с минимальной задержкой на стороне отправителя и сети, проводят максимальное время в буфере компенсации джиттера; и наоборот, пакеты, которые задерживаются дольше минимального времени, проводят затем в данном буфере меньшее время. Кроме того, существует еще, и некоторое минимальное количество времени, которое каждый пакет должен проводить в буфере на стороне получателя, которое может быть столь же велико, как и целый пакет.

\begin{figure} [h]
  \center
\includegraphics[width=0.95\textwidth]{3chapter/2.eps}
  \caption{Задержка в пакетных сетях и сетевых элементах}
  \label{img3:delNode}
\end{figure}

Правильное значение задержки буфера для объединения с другими задержками зависит от наличия описательной статистики. Например, среднюю задержку в сети следует суммировать со средним временем использования буфера компенсации джиттера, чтобы получить общую среднюю задержку. Этот метод предусматривает адаптацию буфера, требуя знания только среднего времени пребывания всех пакетов в очереди в оцениваемом временном интервале. С другой стороны, если известна только минимальная задержка в сети, то ее следует суммировать с максимальным временем использования буфера компенсации джиттера, чтобы дать общую задержку.
Далее рассмотрим инициализацию буфера компенсации джиттера фиксированного размера. Если первый прибывающий пакет имеет минимальную задержку передачи, то получатель будет сохранять этот пакет в буфере все необходимое время, и размер буферизации будет равен ожидаемому. К счастью, многие пакеты прибывают за время, равное или близкое к минимальному времени передачи, поэтому этот случай весьма правдоподобен. 
С другой стороны, если первый пакет имеет довольно большую задержку, то для размещения ранее принятых пакетов со временем передачи, равным или близким к минимальному времени передачи, потребуется больше буферного пространства, а буфер для сглаживания фазового дрожания будет вносить в общий расчет задержку, превышающую ожидаемую.

\section{Систематизация типов, параметров и моделей буферов компенсации джиттера} \label{sect3_3}

Существуют два основных типа буферов компенсации джиттера – фиксированной длины и адаптивной длины. Буферы компенсации джиттера, согласно рекомендации \cite{G1020}, могут быть построены с использованием разных способов, приведенных в табл. \ref{TypeBuff}.


\begin{longtable}{|p{3cm}||p{4cm}|p{4cm}|p{3.5cm}|}
\caption{Типы и параметры буфера компенсации джиттера}\label{TypeBuff}
    \hline
    \hline
    Тип                        & Атрибуты                                                            & \multicolumn{2}{|c|}{Возможности}                                                                                                                                                                    \\ \hline 
    Фиксирован- ный и адаптивный & Размер (конфигурируется максимальная и номинальная или минимальная) & Целое количество пакетов                                                     & Дробное количество пакетов                                                                                            \\  \hline \hline
    \endfirsthead   \hline
 \multicolumn{4}{|c|}{\small\slshape (продолжение)}        \\ \hline
 Тип                        & Атрибуты                                                            & \multicolumn{2}{|c|}{Возможности}                                                                                                                                                                    \\ \hline \hline
        
                                              \endhead        \hline
 \multicolumn{4}{|r|}{\small\slshape продолжение следует}  \\ \hline
                                              \endfoot        \hline
                                              \endlastfoot
\multirow{6}{*}{Адаптивный}    & Управление                                                          & Синхронизиро- ванное ослабление при отсутствии переполнения / антипереполнения & Оценить коэффициент потерь (конфигурировать приемлемый наименьший порог и минимальный счет пакетов между подстройками) \\ 
\cline{2-4}
                               & Подстройка                                                          & Синхронизиро- ванная                                                           & Только в промежутках молчания                                                                                          \\
\cline{2-4}
                               & Инициализация                                                       & Первый пакет                                                                 & Малая выборка                                                                                                          \\ 
\cline{2-4}
                               & Неравномерность подстройки                                          & Размер пакета                                                                & Дробная часть пакета                                                                                                   \\ 
\cline{2-4}
                               & Восстановление порядка пакетов                                      & Да                                                                           & Нет                                                                                                                    \\ 
\cline{2-4}
                               & Режим передачи данных в полосе тональных частот                     & Обнаружение тональной частоты 2100 Гц; установка максимальной длины          & Нет                                                                                                                    \\ 
\hline
    \end{longtable}



Более подробно рассмотрим параметры построения алгоритма адаптивного буфера компенсации джиттера по методу подстройки задержки воспроизведения, такие как алгоритмы выполняющие коррекцию синхронно и алгоритмы выполняющие коррекцию в промежутках между речевыми потоками. 
В схеме с синхронизированной подстройкой задержки воспроизведения (рис. \ref{img3:manageDelay} a) время воспроизведения всех последующих пакетов растягивается всякий раз, когда пакет чрезмерно задерживается в сети. 
Во втором случае, показанном на рис. \ref{img3:manageDelay} б, производится корректировка первого пакета речевого потока, а все остальные пакеты воспроизводятся через фиксированный интервал после первого пакета. Пакеты, прибывшие позже, отбрасываются, и кодек может либо повторить последний принятый пакет или вставить паузу или проиграть другие экстраполированные звуки.


\begin{figure} [h]
\begin{minipage}[h]{0.85\linewidth}
\center
\includegraphics[width=1\linewidth]{3chapter/4a.eps} а) \\
\end{minipage}
\vfill
\begin{minipage}[h]{0.95\linewidth}
\center
\includegraphics[width=1\linewidth]{3chapter/4b.eps} б) \\
\end{minipage}
\caption{Схема регулировки задержки воспроизведения в паузах между речевыми потоками а) с синхронной подстройкой б) с подстройкой первого пакета речевого потока }
\label{img3:manageDelay}
\end{figure}


Синхронизированный способ сводит к минимуму потери пакетов, но влияет на длину исходного речевого потока, что приводит к проблемам с разборчивостью восстановленной речи. По этой причине разрабатываемый буфер компенсации джиттера будет основан на алгоритме с подстройкой задержки только в периоды молчания.


\section{Анализ существующих алгоритмов компенсации джиттера.} \label{sect3_4}
\subsection{Модель фиксированного буфера компенсации джиттера.} \label{sect3_4_1}

Наиболее простой и эффективной моделью отбрасывания пакетов является фиксированный буфер компенсации джиттера, который обозначает, как отбрасываемые, все пакеты, задержка которых больше чем минимальная задержка передачи потока пакетов плюс фиксированная длина буфера для сглаживания джиттера.
Рассмотрим пример алгоритма от сетевого до прикладного уровня, предполагая что на терминале получателя используется буфер компенсации джиттера с фиксированной длиной:
\begin{enumerate}
\item Отметить как потерянные все пакеты с неверной контрольной суммой UDP.
\item Отметить как отбрасываемые все пакеты, задержка которых больше, чем минимальная задержка передачи потока пакетов плюс (фиксированная) длина буфера для сглаживания джиттера, или задержка которых меньше чем установленный минимум. 
\item Суммировать среднюю задержку в сети со средней задержкой терминала источника и терминала получателя, чтобы получить общую среднюю задержку, или суммировать минимальную задержку в терминале источника и минимальную задержку в сети с максимальной задержкой терминала получателя (отражающую максимальное время использования буфера для сглаживания джиттера).
\end{enumerate}

В вышеприведенном шаге 2 минимальную задержку передачи следует оценивать на коротких интервалах, например 10 секунд. Данное минимальное значение первого интервала используется всегда, не считая краткосрочного увеличения минимума вне диапазона адаптации буфера. В этом случае ни один из пакетов не будет доставлен на верхние уровни и буфер компенсации джиттера должен быть переустановлен на новый минимум, что вероятно будет происходить на практике. Или же, если краткосрочное значение минимума уменьшиться до величины, при которой высокий процент (временно 50\%) пакетов были бы помечены как потерянные из-за раннего поступления, то буфер компенсации джиттера должен быть переустановлен на новый минимум.

\subsection{Модель адаптивного буфера компенсации джиттера.} \label{sect3_4_2}

Фиксированный буфер компенсации джиттера может быть заменен эмуляцией адаптивного буфера компенсации джиттера, как описано в данном пункте, когда имеется информация о временной последовательности потока пакетов. 
Временные последовательности поступления пакетов могут быть использованы эмулятором адаптивного буфера компенсации джиттера при определении динамики размера буфера и среднего времени использования буфера (задержка) для этой последовательности. Эта средняя задержка может быть объединена с другими константами задержки в терминале получателя для получения оценки средней задержки в терминале получателя. 
Рассмотрим пример эмулятора адаптивного буфера для сглаживания джиттера с коррекцией задержки в промежутках молчания \cite{Ramjee}. Чтобы определить время воспроизведения для пакета $k$-ого, мы рассмотрим два случая, в зависимости от того является $k$-ый пакет первым в речевом потоке или нет:
Если $k$-ый пакет является первым в речевом потоке $i$, то его время воспроизведения рассчитывается как:

\begin{equation}\label{eq3:playout}
p(k)=t(k)+\hat{x}(k)+\gamma\cdot\hat{\nu}(k),
\end{equation}

\noindent где $\hat{x}(k)$ - оценка средного значения сквозной задержки, $\hat{\nu}(k)$ - оценка отклонения от среднего значения сквозной сетевой задержки, $\gamma$ - константа, используемая для установки времени воспроизведения так чтобы только небольшая часть поступающих пакетов была потеряна \cite{Ramjee}. Эта константа равна 4 во всех экспериментах, выполняемых в \cite{Ramjee}. В \cite{Moon} это значение варьируют от 1 до 20, что бы добиться различного процента потерь. Чтобы пересчитать среднюю сетевую задержку и его отклонение, используются следующие уравнения:

\begin{equation}\label{eq3:playout_d}
\hat{x}^{i}(k)=\alpha\cdot\hat{x}^{i}(k-1)+(1-\alpha)\cdot x^{i}(k),
\end{equation}

\begin{equation}\label{eq3:playout_v}
\hat{\nu}^{i}(k)=\alpha\cdot\hat{\nu}^{i}(k-1)+(1-\alpha)\cdot | \hat{x}^{i}(k)-x^{i}(k) |.
\end{equation}

Эти уравнения представляю собой линейные рекурсивные фильтры, где коэффициент $\alpha$ называется шаговой постоянной, $\alpha\leq1$ и обеспечивает устойчивость процедуры. В работе \cite{Ramjee} значение $\alpha$ выбрано равным 0.98002. 

Очевидно, что эти уравнения являются преобразованными уравнениями стохастической аппроксимации типа Роббинса-Монро и получаемая оценка $\hat{x}^{i}(k)$ и $\hat{\nu}^{i}(k)$, является оптимальной для оценивания случайной величины для которых уравнение состояния $x(k)=x(k-1)$. 
В нашем случае сетевая задержка представляет случайный процесс, поэтому оценки (\ref{eq3:playout_d}), (\ref{eq3:playout_v}) позволяют получить лишь среднии значения задержек. 
Нас же интересуют их текущие значения. Адекватной процедурой для оценки текущих парпметров случайного процесса является процедура Калмана-Бьюси.

\section{Анализ алгоритмов фильтрации помех содержащих выбросы и скачки} \label{sect_analis_filters}

Фильтр Калмана-Бьюси дает решение задачи оптимального оценивания в линейных динамических системах при гауссовском распределение помех.
Однако в нашей прикладной задаче, распределение шумов не является гауссовским, причем распространенной причиной отклонения распределения вероятностей помех от гауссовского является наличие выбросов и скачков в оцениваемом процессе.
Хорошо известно \cite{cipkin}, что такие отклонения существенно ухудшают качество оценок, получаемых с помощью алгоритмов, оптимальных для гауссовских помех.
Поэтому не случайно большое внимание удуляется разаработке робастных алгоритмов фильтрации, стабильно работающих в условиях, когда помехи содержат выбросы или скачки \cite{Klekis, masreliez_ieee, masreliez_martin, ershov_lipcer, ershov, RobustFilter}.
В \cite{masreliez_ieee} задача фильтрации при наличие выбросов решалась, как задача   негаусовской фильтрации, однако реализация полученного алгоритма на ЭВМ представляет затруднительные трудности. 
Дальнейшее развитие этот подход получил в \cite{masreliez_martin}. Однако этот алгоритм фильтрации имеет ряд недостатков: для его построения необходимо знать вероятность появления выброса, что не подходит для решения нашей задачи, так как задержка в телекоммуникационной системе нестационарна, и распределение вероятностей помех должно быть симметричным.

Другой подход к решению задачи фильтрации помех, содержащих выбросы, представлен в \cite{ershov_lipcer, ershov}. В представлении шумов предполагается, что с большей вероятностью помехи измерения распределены нормально с нулевым средним и заданной ковариационной матрицей и с малой вероятностью распределны также нормально,  но с ковариационной матрицей, имеющей большую норму. Алгоритм фильтрации основан на обнаружении момента появления выброса и изменении коэффициента усиления в зависимости от результатов обнаружения. Для модификации коэффициента используется ковариационная матрица источников выбросов.

В \cite{Klekis} предполагается, что в нормальном режиме работы измерительного устройства помехи распределены нормально с нулевым средним и известной ковариационной матрицей, а в режиме сбоев помехи имеют нормальное распределение с неизвестным средним и той же ковариационной матрицей.
Алгоритм фильтрации получен на основе обнаружения момента появления выброса, оценивания его амплитуды и соответствующие модификации коэффициента усиления и ковариационной матрицы. В этом случае априорной информации о характеристиках выбросов не требуется.  

Рассмотрим более детально алгоритмы фильтрации описанные выше:

\textbf{1. Фильтр Калмана (ФК).}
 ФК синтезирован с учетом того, что наблюдаемый процесс соответствует уравнению (\ref{eq3:modelStat}) и наблюдается на фоне гауссовского белого шума.
 Уравнение оценки в виде условного среднего значения задержки с использованием ФК имеет вид:


\begin{equation}\label{eq3:Estim_rel}
\hat{x}(k+1)=\Phi\hat{x}(k)+K(k)\Delta y,
\end{equation}
\noindent где $\Delta y=H\Phi\hat{x}(k)-y(k)$ - невязка, $K(k)$ - коэффициент, обеспечивающий устойчивость и сходимость процедуры, в частности $K(k)$ может быть константой $K\leq1$. Коэффициент усиления ФК $K(k)$ является функцией от апостериорной дисперсии ошибки оценки $V(k)$, что ускоряет его сходимость:

\begin{equation}\label{eq3:K}
K(k)=V(k)H^TN_{\nu}^{-1},
\end{equation}
 
\begin{equation}\label{eq3:V}
V(k)=[I-K(k-1)H(k)]V(k,k-1),
\end{equation}


\begin{equation}\label{eq3:Vkk-1}
V(k,k-1)=\Phi^TV(k-1)\Phi+N_\xi,
\end{equation}

\noindent где $V(k)$ - апостериорная дисперсия ошибки оценки, $V(k,k-1)$ - априорная дисперсия ошибки оценки, $I$ - единичная матрица.

На рис. \ref{img3:kalmanF} представлена схема сглаживающего фильтра, построенная в соответствии с (\ref{eq3:Estim_rel}). Ключевую роль в оценке ФК текущего значения задержки, является параметр $\Phi$ позволяющий регулировать сглаживающие свойства фильтра. 

\begin{figure} [h]
  \center
\includegraphics[width=0.8\textwidth]{3chapter/10.eps}
  \caption{Схема ФК}
  \label{img3:kalmanF}
\end{figure}


\textbf{2. Оптимальный фильтр \cite{Klekis}}, который может быть синтезирован в том случае, когда в (\ref{eq3:v}), (\ref{eq3:vp}) известны последовательности $\{r_v\}$, $\{R_2(k)\}$. Выражения описывающие алгоритм, имеют вид:

\begin{equation}\label{eq3:optim2}
\hat{x}(k+1)=\Phi\hat{x}(k)+K(k)\Delta y,
\end{equation}

\begin{equation}\label{eq3:optim2_3}
V(k|k-1)=\Phi(k-1)V(k-1)\Phi^T(k-1)+N_\xi,
\end{equation}

\begin{equation}\label{eq3:optim2_4}
\begin{split}
K(k)=&V(k|k-1)H^T(k)\{H(k)V(k|k-1)H^T(k)+\\
&+[1-r_v(k)R_1(k)+r_v(k)R_2(k)\}^{-1},
\end{split}
\end{equation}

\begin{equation}\label{eq3:optim2_5}
V(k)=[I-K(k-1)H(k)]V(k,k-1).
\end{equation}

\textbf{3. Оптимальный линейный фильтр \cite{Klekis}} при известной верояности появления выбросов $\varepsilon$ и известных ковариационных матрицах $\{R_2(k)\}$:

\begin{equation}\label{eq3:optim3}
\hat{x}(k+1)=\Phi\hat{x}(k)+K(k)\Delta y,
\end{equation}

\begin{equation}\label{eq3:optim3_3}
V(k|k-1)=\Phi(k-1)V(k-1)\Phi^T(k-1)+N_\xi,
\end{equation}

\begin{equation}\label{eq3:optim3_4}
\begin{split}
K(k)=&V(k|k-1)H^T(k)[H(k)V(k|k-1)H^T(k)+\\
&+(1-\varepsilon)R_1(k)+\varepsilon R_2(k)]^{-1},
\end{split}
\end{equation}

\begin{equation}\label{eq3:optim3_5}
V(k)=[I-K(k-1)H(k)]V(k,k-1).
\end{equation}

\textbf{4. Алгоритм фильтрации, приведенный в \cite{ershov}:}

\begin{equation}\label{eq3:optim4}
\hat{x}(k+1)=\Phi\hat{x}(k)+K(k)\Delta y,
\end{equation}

\begin{equation}\label{eq3:optim4_3}
V(k|k-1)=\Phi(k-1)V(k-1)\Phi^T(k-1)+N_\xi,
\end{equation}

\begin{equation}\label{eq3:optim4_4}
\begin{split}
K(k)=&V(k|k-1)H^T(k)\{H(k)V(k|k-1)H^T(k)+\\
&+(1-\hat{r}_v(k))R_1(k)+\hat{r}_v(k)R_2(k)\}^{-1},
\end{split}
\end{equation}

\begin{equation}\label{eq3:optim4_5}
\begin{split}
V(k)=&[I-K(k-1)H(k)]V(k,k-1)[I-K(k-1)H(k)]^T+\\
&+K(k)R_1(k)K^T(k).
\end{split}
\end{equation}

\begin{equation}
\hat{r}_v(k)= \;
\begin{cases}
0, \; ||\Delta y(k)||\leq c_1 \\    
1, \; ||\Delta y(k)||> c_1    
\end{cases}
\end{equation}

\textbf{5. Алгоритм фильтрации, приведенный в \cite{Klekis}:}

\begin{equation}\label{eq3:optim5}
\hat{x}(k+1)=\Phi\hat{x}(k)+[K(k)-\hat{r}_v(k)K(k)BL(k)]\Delta y,
\end{equation}

\begin{equation}\label{eq3:optim5_1}
L(k)=[B^TVv^{-1}(k)B]^{-1}B^TV^{-1}(k),
\end{equation}

\begin{equation}\label{eq3:optim5_2}
Vv(k)H(k)V(k,k-1)H^T(k)+R_1(k),
\end{equation}

\begin{equation}\label{eq3:optim5_3}
V(k|k-1)=\Phi(k-1)V(k-1)\Phi^T(k-1)+N_\xi,
\end{equation}

\begin{equation}\label{eq3:optim5_4}
K(k)=V(k|k-1)H^T(k)[H(k)V(k|k-1)H^T(k)+R_1(k)]^{-1},
\end{equation}

\begin{equation}\label{eq3:optim5_5}
\begin{split}
V(k)=&[I-K(k-1)H(k)]V(k,k-1)[I-K(k-1)H(k)]^T+\\
&+K(k)R_1(k)K^T(k)+\hat{r}_vK(k)BD(k)B^TK^T(k),
\end{split}
\end{equation}

\begin{equation}\label{eq3:optim5_6}
D(k)=[B^TV^{-1}(k)B]^{-1},
\end{equation}

\begin{equation}\label{eq3:optim5_7}
\hat{r}_v(k)= \;
\begin{cases}
0, \; ||l(k)||\leq c_2 \\    
1, \; ||l(k)||> c_2    
\end{cases}
\end{equation}

\begin{equation}\label{eq3:optim5_8}
l(k)=\Delta y^TV^{-1}(k)B[B^TV^{-1}(k)B]^{-1}B^TV^{-1}(k)\Delta y,
\end{equation}

Из анализа этих алгоритмов \cite{Klekis} отметим что алгоритмы (\ref{eq3:optim4})-(\ref{eq3:optim4_5}) и (\ref{eq3:optim5})-(\ref{eq3:optim5_8}) уступают по точности оптимальному фильтру, но дают более точные оценки, чем ФК.
Ососбенно это характерно в случае мощных выбросов.
По точности алгоритмы (\ref{eq3:optim4})-(\ref{eq3:optim4_5}) и (\ref{eq3:optim5})-(\ref{eq3:optim5_8}) различаются не занчительно, однако в отличии от первого второй не требует информации о характеристиках выбросов

\begin{table} [h]
  \centering
  \parbox{15cm}{\caption{Дисперсия ошибок оценивания в момент $k=20$. $\sigma_{OPT}^2$ - для оптимального фильтра (\ref{eq3:optim2})-(\ref{eq3:optim2_5}), $\sigma_{LIN}^2$ - для линейного фильтра (\ref{eq3:optim3})-(\ref{eq3:optim3_5}), $\sigma_{KAL}^2$ - для ФК, $\sigma_{RB1}^2$ - для алгоритма (\ref{eq3:optim4})-(\ref{eq3:optim4_5}), $\sigma_{RB2}^2$ - для алгоритма (\ref{eq3:optim5})-(\ref{eq3:optim5_8}) \cite{Klekis}} \label{disp_opt}} 
\begin{center}
\begin{tabular}{|l|l|l|l|l|l|l|l|} \hline \hline
$R_1=1$ & $\varepsilon$ & $R_2$ & $\sigma_{OPT}^2$ & $\sigma_{LIN}^2$ & $\sigma_{KAL}^2$ & $\sigma_{RB1}^2$ & $\sigma_{RB2}^2$\\\hline \hline
0,1 & 0,05 & 9 & 0,210 & 0,247 & 0,248 & 0,232 & 0,234\\\hline \hline
0,1 & 0,05 & 36 & 0,211 & 0,314 & 0,367 & 0,222 & 0,222\\\hline
0,1 & 0,05 & 100 & 0,211 & 0,386 & 0,655 & 0,223 & 0,223\\\hline
0,1 & 0,2 & 9 & 0,234 & 0,308 & 0,381 & 0,287 & 0,291\\\hline
0,1 & 0,2 & 36 & 0,235 & 0,410 & 0,921 & 0,277 & 0,273\\\hline
0,1 & 0,2 & 100 & 0,235 & 0,469 & 2,182 & 0,263 & 0,262\\\hline
1 & 0,05 & 9 & 0,633 & 0,748 & 0,782 & 0,744 & 0,746\\\hline
1 & 0,05 & 36 & 0,638 & 1,129 & 1,391 & 0,763 & 0,761\\\hline
1 & 0,05 & 100 & 0,639 & 1,697 & 2,823 & 0,770 & 0.761\\\hline
1 & 0,2 & 9 & 0,792 & 1,093 & 1,332 & 1,066 & 1,072\\\hline
1 & 0,2 & 36 & 0,829 & 1,951 & 3,659 & 1,377 & 1,407\\\hline
1 & 0,2 & 100 & 0,835 & 2,861 & 9,156 & 1,258 & 1,286\\\hline
\end{tabular}
\end{center}
\end{table}

Рассмотренные алгоритмы обладают рядом недостатков:
\begin{enumerate}
 \item Алгоритм ФК дает решение оптимального оценивания в линейных динамических системах при гауссовском распределение помех, а при отклонении от норамальности (выбросы и скачки) качество оценивания существенно ухудшаются.
 \item Для реализации 2-4 алгоритмов необходима априорная информация о характеристиках выбросов, а так как телекоммуникационные системы нестационарны, то практическое применение этих алгоритмов в таких системах ограничено.
 \item Ни один алгоритм не учитывает особенностей, которые необходимо учитывать при фильтрации случайного процесса со скачками.
\end{enumerate}
Для решения этих недостатков рассмотрим ряд алгоритмов из \cite{RobustFilter}.

\subsection{Робастный фильтр Калмана (РФК) для ситуации выброса} \label{sect3_5_1}

Алгоритм РФК для ситуации выброса согласно рекомендации \cite{RobustFilter} выглядит следующим образом:

\begin{equation}\label{eq3:skachok}
\hat{x}(k+1)=\Phi(k+1,k)\hat{x}(k)+K(k)\Delta y\cdot min\left\{1,\frac{b}{|K(k)\Delta y|}\right\},
\end{equation}

\noindent где $b$ является некоторым ограничителем изменения значения функции. 
Это позволяет решить проблему неограниченого изменения оценки за один шаг в классическом фильтре Калмана, оставаясь при этом достаточно простой.

Если $b\geq |K(k) \Delta y |$, то $min\left\{1,\frac{b}{|K(k)\Delta y|}\right\}$ и фильтр работает в обычном режиме как ФК (\ref{eq3:Estim_rel}). Если же $b\leq |K(k) \Delta y |$, то из этого следует, что произошел выброс и невязка умножается на понижающий коэффициент, равный $\frac{b}{|K(k)\Delta y|}$, что опять же приводит РФК к обычному виду (\ref{eq3:Estim_rel}).

\subsection{Робастный фильтр Калмана для ситуации скачка} \label{sect3_5_2}

Алгоритм РФК для ситуации скачка согласно рекомендации \cite{RobustFilter} выглядит следующим образом:

\begin{equation}\label{eq3:vibros}
\begin{split}
\hat{x}(k+1)=&\Phi(k+1,k)\hat{x}(k)+H(k)[I-H(k)K(k)\Delta y]\times \\
&\times min\left\{1,\frac{b}{|I-H(k)K(k)\Delta y|}\right\},
\end{split}
\end{equation}

\noindent где $b$ тот же аргумент, ограничивающий изменение значения функции, что и для РФК для ситуации выброса (\ref{eq3:skachok}).

\subsection{Гибридный робастный фильтр Калмана (ГРФК)} \label{sect3_5_3}

Очевидно, одновременная фильтрация возможна только с некоторой задержкой $\Delta \tau$. Это необходимо для принятия решения о типе выброса. Вследствие выброса скорей всего увидим один большой выброс (\ref{eq3:v}), а вследствие скачка – подряд целую последовательность (\ref{eq3:s}). ГРФК может быть реализован следующим образом \cite{RobustFilter}: РФК для ситуации скачка работает по умолчанию и всякий раз, когда ширина выброса больше окна наблюдения $\Delta \tau$, единожды используется процедура РФК для ситуации скачка.


\section{Получение оценки случайного процесса с выбросами и скачками с помощью робастных фильтров} \label{sect3_6}
Чтобы сравнить алгоритмы фильтрации проведем моделирование оценки случайного процесса с помощью приведенных робастных алгоритмов фильтрации и фильтра Калмана. Результаты приведены на рис. \ref{img3:filterIdeal}-\ref{img3:filterMix}. Сплошной линией со снежинками показан наблюдаемый процесс, сплошной – оценка ФК, штрихпунктирной с точками – РФК для ситуации с выбросами, штрихпунктирной - РФК для ситуации со скачками и штрихпунктирной со снежинками – ГРФК. На рис. \ref{img3:filterIdeal} представлены результаты оценивания временного процесса без выбросов и скачков (\ref{eq3:Estim}), из графика следует, что рассмотренные робастные алгоритмы, не теряют своей оптимальности по сравнению с ФК, во время оценивания процесса без выбросов и скачков.
На рис. \ref{img3:filterVibros} представлены результаты оценивания временного процесса с выбросами (\ref{eq3:v}), из графика следует, что РФК для ситуации выброса и ГРФК позволяют игнорировать выбросы, что обеспечивает оптимальную оценку процесса.
На рис. \ref{img3:filterSkachok} представлены результаты оценивания временного процесса со скачками (\ref{eq3:v}), из графика следует, что РФК для ситуации скачка и ГРФК позволяют быстро переключиться на новое значение задержки. В то время как РФК для ситуации выброса оказался не в состоянии отслеживать скачки.
В заключение, на рис. \ref{img3:filterMix} представлены результаты оценивания временного процесса со скачками и с выбросами, из графика следует, что, ГРФК позволяет получить оптимальную оценку в смешанной ситуации, в то время как остальные алгоритмы выполняют оценку недопустимо плохо.


\pgfplotsset{width=15cm, height=10cm, compat=1.3}
\begin{figure} [h]
  \center
\begin{tikzpicture}
%\pgfkeys{/pgfplots/legend pos=north west}

\begin{axis}[
mark options={scale=0.5},
ylabel={Mem [GB]},
legend style={
%area legend,
at={(0.5,-0.20)},
anchor=north,
legend columns=3},
legend cell align=left,
cycle list name=mark list,
%cycle list name=linestyles,
xlabel=Порядковый номер пакета,
ylabel=Задержка (мс),
xmin=200,
xmax=300
]

\input{graphs/2}

\legend{Задержка, ФК, РФК(выбросы), РФК(скачки), ГРФК}
\end{axis}
\end{tikzpicture}
\caption{Моделирование фильтрации в идеальных условиях}
  \label{img3:filterIdeal}
\end{figure}

\pgfplotsset{width=15cm, height=9cm, compat=1.3}
\begin{figure} [h]
  \center
\begin{tikzpicture}
%\pgfkeys{/pgfplots/legend pos=north west}

\begin{axis}[
mark options={scale=0.5},
ylabel={Mem [GB]},
legend style={
%area legend,
at={(0.5,-0.2)},
anchor=north,
legend columns=3},
legend cell align=left,
cycle list name=mark list,
%cycle list name=linestyles,
xlabel=Порядковый номер пакета,
ylabel=Задержка (мс),
xmin=0,
xmax=40
]

\input{graphs/3}

\legend{Задержка, ФК, РФК(выбросы), РФК(скачки), ГРФК}
\end{axis}
\end{tikzpicture}
\caption{Моделирование фильтрации при выбросах}
  \label{img3:filterVibros}
\end{figure}



\pgfplotsset{width=15cm, height=9cm, compat=1.3}
\begin{figure} [h]
  \center
\begin{tikzpicture}
%\pgfkeys{/pgfplots/legend pos=north west}

\begin{axis}[
mark options={scale=0.5},
ylabel={Mem [GB]},
legend style={
%area legend,
at={(0.5,-0.2)},
anchor=north,
legend columns=3},
legend cell align=left,
cycle list name=mark list,
%cycle list name=linestyles,
xlabel=Порядковый номер пакета,
ylabel=Задержка (мс),
xmin=280,
xmax=350
]

\input{graphs/3}

\legend{Задержка, ФК, РФК(выбросы), РФК(скачки), ГРФК}
\end{axis}
\end{tikzpicture}
\caption{Моделирование фильтрации при скачках}
  \label{img3:filterSkachok}
\end{figure}

\clearpage

\pgfplotsset{width=15cm, height=10cm, compat=1.3}
\begin{figure} [h]
  \center
\begin{tikzpicture}
%\pgfkeys{/pgfplots/legend pos=north west}

\begin{axis}[
mark options={scale=0.5},
ylabel={Mem [GB]},
legend style={
%area legend,
at={(0.5,-0.2)},
anchor=north,
legend columns=3},
legend cell align=left,
cycle list name=mark list,
%cycle list name=linestyles,
xlabel=Порядковый номер пакета,
ylabel=Задержка (мс),
xmin=380,
xmax=480
]

\input{graphs/3}

\legend{Задержка, ФК, РФК(выбросы), РФК(скачки), ГРФК}
\end{axis}
\end{tikzpicture}
\caption{Моделирование фильтрации в смешанной ситуации скачков и выбросов}
  \label{img3:filterMix}
\end{figure}




В процессе эксперимента был получен средний квадрат отклонений (СКО) оценки в различных ситуациях зашумленности (скачки и выбросы) с помощью рассмотренных фильтров и результаты приведены в табл. \ref{fkDiffSit}



\begin{table} [h]
  \centering
  \parbox{15cm}{\caption{Типы и параметры буфера компенсации джиттера}\label{fkDiffSit}}
\begin{tabular}{|p{3cm}|p{3cm}|p{3cm}|p{3cm}|p{3cm}|}
    \hline
    Тип фильтра        & Условия без выбросов и скачков & Условия со скачками & Условия с выбросами & Условия с выбросами и скачками \\ \hline
    ФК                 & 6,48                           & 6                   & \textbf{2,7}                 & 26,6                           \\ \hline
    РФК (для выбросов) & 11,02                          & 29,93               & 3,2                 & 23,1                           \\ \hline
    РФК (для скчков)   & \textbf{2,15}                           & \textbf{0,85}                & 19,8                & 42                             \\ \hline
    ГРФК               & 31,08                          & 10,93               & 27,4                & \textbf{14,4}                           \\ \hline
    \end{tabular}
\end{table}








Жирным шрифтом выделены лучшие результаты оценок по сравнению с другими фильтрами для каждой шумовой ситуации. Как и предполагалось, для ситуации с выбросами и скачками наилучший результат показал гибридный робастный фильтр Калмана.
\clearpage

\section{Синтез алгоритма буфера компенсатора джиттера} \label{sect3_5}

Размер буфера пересчитывается по формуле (\ref{eq3:playout}) только во время пауз между речевыми потоками, где $\hat{x}(k)$ рассчитывается как:

\begin{equation}\label{eq3:syntes1}
\begin{split}
\hat{x}(k+1)=&(1-\eta) \Phi(k+1,k)\hat{x}(k)+K(k)\Delta y\times \\
&\times min\left\{1,\frac{b}{|K(k)\Delta y|}\right\}+\eta \Phi(k+1,k)\hat{x}(k)+\\
&+H(k)[I-H(k)K(k)\Delta y] min\left\{1,\frac{b}{|I-H(k)K(k)\Delta y|}\right\},
\end{split}
\end{equation}

\begin{equation}\label{eq3:syntes2}
\eta= \;
\begin{cases}
0, \; cond(k) \\    
1, \; cond(k),    
\end{cases}
\end{equation}
\noindent где $cond(k)$ - функция, которая определяет произошел ли скачок задержки в окне наблюдения или нет:
\begin{verbatim}
 1  def cond(arr, w, b):  
 2    try:  # проверка, что количество элементов 
 3          # в массиве не меньше, чем окно наблюдения
 4      arr[-w] 
 5    except IndexError:
 6      return False
 7    if arr[-w]<b:
 8      return False
 9    if w==1 and arr[-w]>=b:
 10      return True
 11   if k==1 and arr[-w]<b:
 12     return False
 13   else:
 14     if cond(arr, w-1, b):
 15       return True  # обнаружен скачек задержки
 16     else:
 17       return False  # не обнаружен скачек задержки
\end{verbatim}

Оценка отклонения $\hat{\nu}(k)$ от условного среднего значения сквозной задержки рассчитывается как:

\begin{equation}\label{eq3:syntes4}
\hat{\nu}(k)=\alpha\cdot\hat{\nu}(k-1)+(1-\alpha)\cdot \nu(k).
\end{equation}

\begin{equation}\label{eq3:syntes3}
\nu^i(k)= \;
\begin{cases}
| \hat{x}(k)-x(k) |, \; K(k)\Delta y \leq b \\    
\nu(k-1), \;  K(k)\Delta y > b,    
\end{cases}
\end{equation}

Для внедрения полученного алгоритма компенсации джиттера в сеть LTE можно воспользоваться концепцией потоковых агентов, которая далее будут рассмотрена.

\section{Обзор концепции потоковых агентов} \label{sect_sa}



При передаче мультимедийной информации по комбинированным сетям с учетом различных механизмов распространения с различными технологиями, важным является выполнение требований по качеству предоставления мультимедийной информации пользователю.
При этом важными являются такие характеристики: задержка, джиттер, число потерянных и поврежденных пакетов. Как показывает практика наибольшие потери качественных характеристик происходят на границах операторских сетей и сетей с различными механизмами распространения.
Возникает необходимость установки соответствующих агентов, обеспечивающих мониторинг на том или ином промежутке сети. Вместе с тем от числа и места этих агентов существенно зависит качество мониторинга.
Потоковый агент (ПА) это агент, который находится на базовой станции на пересечении проводной и беспроводной сети (рис. \ref{img:SA}). Агент просматривает и распознает поток, исследуя заголовки RTP. Агент периодически посылает статистические и обратные сообщения в реальном времени на отправляющий сервер. Статистические обратные связи помогают отправителю проследить проводное состояние сети, что существенно для выполнения надлежащего контроля над перегрузками. С другой стороны, потоковый агент отправляет обратные сообщения в реальном времени, такие как подтверждение пакетов (ACKs), что говорит отправителю о прибытии каждого пакета к агенту корректно и вовремя.


\begin{figure} [h]
  \center
\includegraphics [width=0.95\textwidth] {SA.eps}
  \caption{Использование ПА}
  \label{img:SA}
\end{figure}

Блок формирования находится перед ПА и ограничивает объем отправляемых сообщений, чтобы он не был больше чем полоса пропускания беспроводной сети, храня пакеты, ожидающие фрагментацию и передачу на более низкий уровень. Если состояние беспроводной сети плохое, то число повторных передач будет расти, заставляя увеличиваться очередь пакетов. Блок формирования реагирует на заполненность очереди, отбрасывая пакеты до прибытия их к агенту.

ПА позволяет выполнять множество функций для улучшения качества предоставления мультимедийных услуг:
\begin{itemize}
\item ПА предоставляет дополнительную обратную связь для контент сервера с границы между проводной  и беспроводной частью сети \cite{SAdouble_feedback}.
\item ПА дает возможность определить место пакетной ошибки \cite{SAdouble_feedback}, что позваляет корректно реагировать на потери и задержки в сети.
\item Предварительное отбрасывание пакетов, которые передаются сверх возможностей беспроводной сети.
\item Ретрансляция на прикладном уровне позволяет уменьшить  пакетные искажения  для приложений не восприимчивых к задержке \cite{SArateOpt, SArealtime}.
\item Прямая коррекция ошибок позволяет уменьшить битовые искажения для приложений восприимчивых к задержке \cite{SArateOpt, SArealtime}.
\end{itemize}

Использование ПА, как платформу для внедрения буфера компенсации джиттера позволяет выполнять предварительную компенсацию джиттера в сети и тем самым упростить задачу буфера воспроизведения  на конечном устройстве.




\section{Выводы ко \ref{chapt3} разделу} \label{sect:concl3}

\begin{enumerate}
 \item Проведен анализ алгоритмов фильтрации для оценки текущего состояния случайного процесса с выбросами и скачками. Выбран алгоритм фильтрации, обладающий рядом необходимых свойств, которые позволяют на его основе реализовать алгоритм буфера компенсации джиттера. Проведен анализ работы выбранного алгоритма с рядом задержек, которые были сгенерированы с помощью математической модели процесса задержки (\ref{eq3:v} и (\ref{eq3:s}). Отметим (табл. \ref{fkDiffSit}), что выбранный алгоритм фильтрации превосходит остальные в условиях с выбросами и скачками.
 \item Разработан инвариантный алгоритм буфера компенсации джиттера, который позволяет решить ряд проблем возникающих, когда процесс пакетной задержки отклоняется от нормального распределения и имеет выбросы и скачки. Сравнительный анализ работы предложенного алгоритма с реальными задержками, которые были получены при анализе основных источников джиттера в проводных и беспроводных сетях в разделе \ref{chapt2} проведем в разделе \ref{chapt4}.
 \item Использование потоковых агентов позволяет решить проблему внедрения предложенного буфера компенсации джиттера в сеть LTE, избегая при этом дополнительных затрат так, как его внедрение можно реализовать простым обновлением программного обеспечения на SGW/PGW узле. Также ПА на данный момент уже имет целый ряд полезных функций, которые решают множество проблем на границе разделения сред для потокового трафика.
 \end{enumerate}



